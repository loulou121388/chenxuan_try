<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #0ff; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 999;
            transition: opacity 0.5s;
        }
        #error-msg { color: #ff3333; margin-top: 20px; text-align: center; display: none; }
        #ui-container { position: absolute; top: 0; left: 0; z-index: 10; }
        video { display: none; } /* 隐藏原始视频流 */
    </style>

    <!-- 1. 引入 MediaPipe 全局脚本 (比模块加载更稳定) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- 2. 配置 Import Map 用于 Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
            }
        }
    </script>
</head>
<body>

    <div id="loader">
        <div>正在初始化系统...</div>
        <div style="font-size: 0.8em; color: #666; margin-top: 10px;">请允许摄像头权限</div>
        <div id="error-msg"></div>
    </div>
    
    <video id="input-video" playsinline></video>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import GUI from 'lil-gui';

        // 错误处理工具
        function showError(msg) {
            const el = document.getElementById('error-msg');
            el.style.display = 'block';
            el.innerHTML = msg;
            console.error(msg);
        }

        // --- 核心变量 ---
        const CONFIG = {
            count: 20000,
            size: 0.2,
            color: '#00ffff',
            shape: 'Heart',
            dispersion: 0
        };
        
        let scene, camera, renderer, composer, particles, geometry;
        let targetPositions = [], currentPositions = [];
        
        // --- 程序化生成纹理 (解决图片404问题) ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // --- 初始化 Three.js ---
        function initThree() {
            try {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                camera.position.z = 25;

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                // 简单的 OrbitControls
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.autoRotate = true;
                controls.autoRotateSpeed = 1.0;

                // 后期处理
                const renderPass = new RenderPass(scene, camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                composer = new EffectComposer(renderer);
                composer.addPass(renderPass);
                composer.addPass(bloomPass);

                // 粒子系统
                geometry = new THREE.BufferGeometry();
                const pos = [];
                for(let i=0; i<CONFIG.count; i++) {
                    pos.push((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
                    targetPositions.push(0,0,0);
                }
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                
                const material = new THREE.PointsMaterial({
                    size: CONFIG.size,
                    color: CONFIG.color,
                    map: createGlowTexture(), // 使用代码生成的纹理
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                particles = new THREE.Points(geometry, material);
                scene.add(particles);

                // UI
                const gui = new GUI();
                gui.add(CONFIG, 'shape', ['Heart', 'Sphere', 'Cube', 'Saturn']).onChange(generateShape);
                gui.addColor(CONFIG, 'color').onChange(c => material.color.set(c));
                
                // 窗口大小调整
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth/window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    composer.setSize(window.innerWidth, window.innerHeight);
                });

                generateShape('Heart');
                animate();

            } catch (e) {
                showError("3D环境初始化失败: " + e.message);
            }
        }

        // --- 形状生成 ---
        function generateShape(type) {
            const count = CONFIG.count;
            const temp = [];
            for(let i=0; i<count; i++) {
                let x=0, y=0, z=0;
                if(type === 'Heart') {
                    const t = Math.random() * Math.PI * 2;
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI;
                    x = 16 * Math.pow(Math.sin(u), 3);
                    y = 13 * Math.cos(u) - 5*Math.cos(2*u) - 2*Math.cos(3*u) - Math.cos(4*u);
                    z = x * Math.cos(v) * 0.5;
                    x *= Math.sin(v) * 0.5; y *= 0.5; z *= 0.5;
                } else if (type === 'Sphere') {
                    const r = 10;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2*Math.random()-1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                } else if (type === 'Saturn') {
                    // 简化的土星逻辑
                    if(Math.random() > 0.3) { // 环
                        const r = 12 + Math.random()*5;
                        const a = Math.random()*Math.PI*2;
                        x=r*Math.cos(a); z=r*Math.sin(a); y=(Math.random()-0.5);
                    } else { // 球
                        const r=6; const t=Math.random()*6.28; const p=Math.acos(2*Math.random()-1);
                        x=r*Math.sin(p)*Math.cos(t); y=r*Math.sin(p)*Math.sin(t); z=r*Math.cos(p);
                    }
                    // 倾斜
                    let ty = y*Math.cos(0.5) - z*Math.sin(0.5);
                    let tz = y*Math.sin(0.5) + z*Math.cos(0.5);
                    y=ty; z=tz;
                } else {
                    // Cube
                    x = (Math.random()-0.5)*15;
                    y = (Math.random()-0.5)*15;
                    z = (Math.random()-0.5)*15;
                }
                temp.push(x, y, z);
            }
            // 更新目标数组
            for(let i=0; i<temp.length; i++) targetPositions[i] = temp[i];
        }

        // --- 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);
            const positions = geometry.attributes.position.array;
            
            // 粒子运动逻辑
            for(let i=0; i<CONFIG.count; i++) {
                const ix = i*3;
                let tx = targetPositions[ix], ty = targetPositions[ix+1], tz = targetPositions[ix+2];
                
                // 手势扩散逻辑
                if(CONFIG.dispersion > 0.05) {
                    const d = CONFIG.dispersion * 5; 
                    tx += (Math.random()-0.5) * d * 10;
                    ty += (Math.random()-0.5) * d * 10;
                    tz += (Math.random()-0.5) * d * 10;
                }

                // 平滑插值
                positions[ix] += (tx - positions[ix]) * 0.05;
                positions[ix+1] += (ty - positions[ix+1]) * 0.05;
                positions[ix+2] += (tz - positions[ix+2]) * 0.05;
            }
            geometry.attributes.position.needsUpdate = true;
            composer.render();
        }

        // --- 初始化 MediaPipe ---
        async function initMediaPipe() {
            if (!window.Hands) {
                showError("MediaPipe 库加载失败，请检查网络");
                return;
            }

            try {
                const video = document.getElementById('input-video');
                const hands = new window.Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});

                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });

                hands.onResults((results) => {
                    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                        const ls = results.multiHandLandmarks[0];
                        const d = Math.sqrt(Math.pow(ls[4].x - ls[8].x, 2) + Math.pow(ls[4].y - ls[8].y, 2));
                        // 映射逻辑: d越小(捏合) -> dispersion越大
                        // d 范围约 0.02 (捏) ~ 0.2 (张)
                        let val = 1 - (d - 0.02) / (0.15); 
                        CONFIG.dispersion = Math.max(0, Math.min(1, val));
                    } else {
                        CONFIG.dispersion *= 0.9; // 没手时慢慢恢复
                    }
                });

                const cameraUtils = new Camera(video, {
                    onFrame: async () => {
                        await hands.send({image: video});
                    },
                    width: 640,
                    height: 480
                });
                
                await cameraUtils.start();
                document.getElementById('loader').style.display = 'none';

            } catch(e) {
                showError("摄像头启动失败: " + e.message + "<br>请确保在 HTTPS 或 Localhost 下运行");
            }
        }

        // 启动流程
        initThree();
        window.onload = initMediaPipe;

    </script>
</body>
</html>